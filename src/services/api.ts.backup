
import { db } from './db.server';
import { eq, ilike, asc, desc, and, or } from 'drizzle-orm';
import { 
  systemConfig, menuDishes, orders, menuCategories, partners, 
  users, paymentMethods, ingredients, expenses, rooms 
} from '../../drizzle/schema';

// æ¼”ç¤ºæ¨¡å¼ä»ç„¶ä¿ç•™ï¼Œä½†åœ¨ç”Ÿäº§ç¯å¢ƒä¸­ä¼˜å…ˆä½¿ç”¨drizzle
const isDemoMode = !process.env.POSTGRES_URL;

// å¼ºåˆ¶æ£€æŸ¥æ•°æ®åº“è¿æ¥å­—ç¬¦ä¸²
const isProductionDB = !!process.env.POSTGRES_URL;

if (isProductionDB) {
  console.log("ğŸš€ APIå±‚ï¼šç”Ÿäº§æ•°æ®åº“å·²å°±ç»ªï¼Œæ­£åœ¨å…³é—­ Demo æ¨¡å¼...");
  // åˆå§‹åŒ–ç”Ÿäº§ç¯å¢ƒæ•°æ®ç½‘å…³
} else {
  console.warn("âš ï¸ APIå±‚ï¼šæœªæ£€æµ‹åˆ° POSTGRES_URLï¼Œç³»ç»Ÿè¿›å…¥æ¼”ç¤ºæ¨¡å¼ã€‚");
}
import { 
  Partner, Order, Dish, OrderStatus, SystemConfig, UserRole, 
  Category, Ingredient, PaymentMethodConfig, HotelRoom, User, Expense
} from '../types';
import { INITIAL_DISHES, INITIAL_CATEGORIES } from '../constants';

/**
 * æ±Ÿè¥¿äº‘å¨ - ç”Ÿäº§çº§æ•°æ®ç½‘å…³ (Cloud Engine v10.5)
 * æ ¸å¿ƒé€»è¾‘ï¼šå½»åº•æ‰“é€šå…¨ä¸šåŠ¡çº¿çš„ç‰©ç†å±‚æŒä¹…åŒ–ã€‚
 */

export const api = {
  config: {
    get: async (): Promise<SystemConfig> => {
      if (isDemoMode) return { hotelName: 'æ±Ÿè¥¿äº‘å¨(æ¼”ç¤º)', theme: 'light', autoPrintOrder: true, ticketStyle: 'standard', fontFamily: 'Plus Jakarta Sans' } as any;
      try {
        const result = await db.select().from(systemConfig).where(eq(systemConfig.id, 'global')).execute();
        const data = result[0];
        if (!data) return { hotelName: 'æ±Ÿè¥¿äº‘å¨', theme: 'light', autoPrintOrder: true, ticketStyle: 'standard', fontFamily: 'Plus Jakarta Sans' } as any;
        return {
          hotelName: data.hotelName,
          version: data.version,
          theme: data.theme || 'light',
          autoPrintOrder: data.autoPrintOrder ?? true,
          ticketStyle: data.ticketStyle || 'standard',
          fontFamily: data.fontFamily || 'Plus Jakarta Sans'
        } as any;
      } catch (error) {
        console.error("è·å–ç³»ç»Ÿé…ç½®å¤±è´¥:", error);
        return { hotelName: 'æ±Ÿè¥¿äº‘å¨', theme: 'light', autoPrintOrder: true, ticketStyle: 'standard', fontFamily: 'Plus Jakarta Sans' } as any;
      }
    },
    update: async (config: SystemConfig) => {
      if (isDemoMode) return;
      try {
        await db.insert(systemConfig).values({
          id: 'global',
          hotelName: config.hotelName,
          theme: config.theme,
          autoPrintOrder: config.autoPrintOrder,
          ticketStyle: config.ticketStyle,
          fontFamily: config.fontFamily,
        }).onConflictDoUpdate({
          target: systemConfig.id,
          set: {
            hotelName: config.hotelName,
            theme: config.theme,
            autoPrintOrder: config.autoPrintOrder,
            ticketStyle: config.ticketStyle,
            fontFamily: config.fontFamily,
            updatedAt: new Date()
          }
        }).execute();
      } catch (error) {
        console.error("æ›´æ–°ç³»ç»Ÿé…ç½®å¤±è´¥:", error);
      }
    }
  },

  rooms: {
    getAll: async (): Promise<HotelRoom[]> => {
      if (isDemoMode) {
        // ä½¿ç”¨ä¸ constants.ts ä¸­ä¸€è‡´çš„æˆ¿é—´å·
        const { ROOM_NUMBERS } = await import('../constants');
        return ROOM_NUMBERS.map(id => ({ id, status: 'ready' }));
      }
      try {
        const data = await db.select().from(rooms).orderBy(asc(rooms.id)).execute();
        return data.map((r: any) => ({ id: r.id, status: r.status }));
      } catch (error) {
        console.error("è·å–æˆ¿é—´åˆ—è¡¨å¤±è´¥:", error);
        throw error;
      }
    },
    updateStatus: async (id: string, status: string) => {
      if (isDemoMode) return;
      try {
        await db.update(rooms).set({ 
          status, 
          updatedAt: new Date() 
        }).where(eq(rooms.id, id)).execute();
      } catch (error) {
        console.error("æ›´æ–°æˆ¿é—´çŠ¶æ€å¤±è´¥:", error);
      }
    }
  },

  dishes: {
    getAll: async (sessionUser?: any): Promise<Dish[]> => {
      if (isDemoMode) return INITIAL_DISHES;
      try {
        let query = db.select().from(menuDishes);
        if (sessionUser?.role === UserRole.PARTNER && sessionUser.partnerId) {
          query = query.where(eq(menuDishes.partnerId, sessionUser.partnerId));
        }
        const data = await query.orderBy(asc(menuDishes.id)).execute();
        return data.map((d: any) => ({
          id: d.id, name: d.name, name_en: d.nameEn, description: d.description,
          tags: d.tags || [], price: Number(d.price), category: d.category,
          stock: d.stock, image_url: d.imageUrl, is_available: d.isAvailable,
          is_recommended: d.isRecommended, partnerId: d.partnerId
        }));
      } catch (error) {
        console.error("è·å–èœå“åˆ—è¡¨å¤±è´¥:", error);
        return INITIAL_DISHES;
      }
    },
    create: async (data: Dish, sessionUser: any) => {
      if (isDemoMode) return;
      try {
        const partnerId = sessionUser?.role === UserRole.PARTNER ? sessionUser.partnerId : data.partnerId;
        await db.insert(menuDishes).values({
          id: data.id, name: data.name, nameEn: data.name_en, description: data.description,
          tags: data.tags, price: data.price, category: data.category, stock: data.stock,
          imageUrl: data.image_url, isAvailable: data.is_available,
          isRecommended: data.is_recommended, partnerId: partnerId
        }).execute();
      } catch (error) {
        console.error("åˆ›å»ºèœå“å¤±è´¥:", error);
      }
    },
    update: async (data: Dish, sessionUser: any) => {
      if (isDemoMode) return;
      try {
        const updateQuery = db.update(menuDishes).set({
          name: data.name, nameEn: data.name_en, description: data.description,
          tags: data.tags, price: data.price, category: data.category, stock: data.stock,
          imageUrl: data.image_url, isAvailable: data.is_available, isRecommended: data.is_recommended
        }).where(eq(menuDishes.id, data.id));
        
        if (sessionUser.role !== UserRole.ADMIN) {
          updateQuery.where(and(
            eq(menuDishes.id, data.id),
            eq(menuDishes.partnerId, sessionUser.partnerId)
          ));
        }
        await updateQuery.execute();
      } catch (error) {
        console.error("æ›´æ–°èœå“å¤±è´¥:", error);
      }
    },
    delete: async (id: string, sessionUser: any) => {
      if (isDemoMode) return;
      try {
        let deleteQuery = db.delete(menuDishes).where(eq(menuDishes.id, id));
        if (sessionUser.role !== UserRole.ADMIN) {
          deleteQuery = deleteQuery.where(eq(menuDishes.partnerId, sessionUser.partnerId));
        }
        await deleteQuery.execute();
      } catch (error) {
        console.error("åˆ é™¤èœå“å¤±è´¥:", error);
      }
    }
  },

  orders: {
    getAll: async (sessionUser?: any): Promise<Order[]> => {
      if (isDemoMode) return [];
      try {
        let query = db.select().from(orders);
        if (sessionUser?.role === UserRole.PARTNER && sessionUser.partnerId) {
          // å¯¹äºåˆä¼™äººï¼Œæˆ‘ä»¬ç­›é€‰ä»–ä»¬çš„è®¢å• - æ³¨æ„è¿™é‡Œéœ€è¦æ£€æŸ¥itemså­—æ®µä¸­æ˜¯å¦åŒ…å«partnerId
          // ç”±äºitemsæ˜¯JSONBå­—æ®µï¼Œæˆ‘ä»¬éœ€è¦ç‰¹æ®Šçš„å¤„ç†æ–¹å¼
          query = query.where(ilike(orders.items, `%${sessionUser.partnerId}%`));
        }
        const data = await query.orderBy(desc(orders.createdAt)).execute();
        return data.map((o: any) => ({
          id: o.id, roomId: o.roomId, customerId: o.customerId, items: o.items,
          totalAmount: Number(o.totalAmount), status: o.status as OrderStatus,
          paymentMethod: o.paymentMethod, paymentProof: o.paymentProof,
          cash_received: Number(o.cashReceived || 0), cash_change: Number(o.cashChange || 0),
          createdAt: o.createdAt, updatedAt: o.updatedAt
        }));
      } catch (error) {
        console.error("è·å–è®¢å•åˆ—è¡¨å¤±è´¥:", error);
        return [];
      }
    },
    create: async (data: Order) => {
      if (isDemoMode) return;
      try {
        await db.insert(orders).values({
          id: data.id, roomId: data.roomId, customerId: data.customerId,
          items: data.items, totalAmount: data.totalAmount, status: data.status,
          paymentMethod: data.paymentMethod, paymentProof: data.paymentProof,
          cashReceived: data.cash_received, cashChange: data.cash_change
        }).execute();
      } catch (error) {
        console.error("åˆ›å»ºè®¢å•å¤±è´¥:", error);
      }
    },
    updateStatus: async (id: string, status: OrderStatus) => {
      if (isDemoMode) return;
      try {
        await db.update(orders).set({ 
          status, 
          updatedAt: new Date() 
        }).where(eq(orders.id, id)).execute();
      } catch (error) {
        console.error("æ›´æ–°è®¢å•çŠ¶æ€å¤±è´¥:", error);
      }
    }
  },

  categories: {
    getAll: async (): Promise<Category[]> => {
      if (isDemoMode) return INITIAL_CATEGORIES;
      try {
        const data = await db.select().from(menuCategories).orderBy(asc(menuCategories.displayOrder)).execute();
        return data.map((c: any) => ({
          id: c.id, name: c.name, name_en: c.nameEn, code: c.code, level: c.level,
          display_order: c.displayOrder, is_active: c.isActive, parent_id: c.parentId, partnerId: c.partnerId
        }));
      } catch (error) {
        console.error("è·å–åˆ†ç±»åˆ—è¡¨å¤±è´¥:", error);
        return INITIAL_CATEGORIES;
      }
    },
    saveAll: async (cats: Category[]) => {
      if (isDemoMode) return;
      try {
        const payload = cats.map(c => ({
          id: c.id, name: c.name, nameEn: c.name_en, code: c.code, level: c.level,
          displayOrder: c.display_order, isActive: c.is_active, parentId: c.parent_id, partnerId: c.partnerId
        }));
        await db.insert(menuCategories).values(payload).onConflictDoUpdate({
          target: menuCategories.id,
          set: {
            name: (c: typeof menuCategories.$inferInsert) => c.name,
            nameEn: (c: typeof menuCategories.$inferInsert) => c.nameEn,
            code: (c: typeof menuCategories.$inferInsert) => c.code,
            level: (c: typeof menuCategories.$inferInsert) => c.level,
            displayOrder: (c: typeof menuCategories.$inferInsert) => c.displayOrder,
            isActive: (c: typeof menuCategories.$inferInsert) => c.isActive,
            parentId: (c: typeof menuCategories.$inferInsert) => c.parentId,
            partnerId: (c: typeof menuCategories.$inferInsert) => c.partnerId
          }
        }).execute();
      } catch (error) {
        console.error("ä¿å­˜åˆ†ç±»å¤±è´¥:", error);
      }
    }
  },

  partners: {
    getAll: async (): Promise<Partner[]> => {
      if (isDemoMode) return [];
      try {
        const data = await db.select().from(partners).orderBy(asc(partners.name)).execute();
        return data.map((p: any) => ({
          id: p.id, name: p.name, ownerName: p.ownerName, status: p.status,
          commissionRate: Number(p.commissionRate), balance: Number(p.balance),
          contact: p.contact, email: p.email, authorizedCategories: p.authorized_categories || [],
          totalSales: Number(p.totalSales || 0), joinedAt: p.createdAt
        } as any));
      } catch (error) {
        console.error("è·å–åˆä¼™äººåˆ—è¡¨å¤±è´¥:", error);
        return [];
      }
    },
    getProfile: async (userId: string): Promise<Partner | null> => {
      if (isDemoMode) return null;
      try {
        // é¦–å…ˆè·å–ç”¨æˆ·ä¿¡æ¯
        const userDataResult = await db.select({ partnerId: users.partnerId }).from(users).where(eq(users.id, userId)).execute();
        const userData = userDataResult[0];
        if (!userData?.partnerId) return null;
        
        // ç„¶åè·å–åˆä¼™äººä¿¡æ¯
        const partnerDataResult = await db.select().from(partners).where(eq(partners.id, userData.partnerId)).execute();
        const partnerData = partnerDataResult[0];
        if (!partnerData) return null;
        
        return {
          id: partnerData.id, name: partnerData.name, ownerName: partnerData.ownerName,
          status: partnerData.status, commissionRate: Number(partnerData.commissionRate),
          balance: Number(partnerData.balance), contact: partnerData.contact, email: partnerData.email,
          authorizedCategories: partnerData.authorized_categories || [], totalSales: Number(partnerData.totalSales || 0),
          joinedAt: partnerData.createdAt
        } as any;
      } catch (error) {
        console.error("è·å–åˆä¼™äººèµ„æ–™å¤±è´¥:", error);
        return null;
      }
    },
    create: async (data: Partner) => {
      if (isDemoMode) return;
      try {
        await db.insert(partners).values({
          id: data.id, name: data.name, ownerName: data.ownerName, status: data.status,
          commissionRate: data.commissionRate, balance: data.balance,
          contact: data.contact, email: data.email, authorized_categories: data.authorizedCategories,
          totalSales: data.totalSales
        }).execute();
      } catch (error) {
        console.error("åˆ›å»ºåˆä¼™äººå¤±è´¥:", error);
      }
    },
    update: async (data: Partner) => {
      if (isDemoMode) return;
      try {
        await db.update(partners).set({
          name: data.name, ownerName: data.ownerName, status: data.status,
          commissionRate: data.commissionRate, contact: data.contact, email: data.email,
          authorized_categories: data.authorizedCategories
        }).where(eq(partners.id, data.id)).execute();
      } catch (error) {
        console.error("æ›´æ–°åˆä¼™äººå¤±è´¥:", error);
      }
    },
    delete: async (id: string) => {
      if (isDemoMode) return;
      try {
        await db.delete(partners).where(eq(partners.id, id)).execute();
      } catch (error) {
        console.error("åˆ é™¤åˆä¼™äººå¤±è´¥:", error);
      }
    }
  },

  expenses: {
    getAll: async (): Promise<Expense[]> => {
      if (isDemoMode) return [];
      try {
        const data = await db.select().from(expenses).orderBy(desc(expenses.date)).execute();
        return data.map((e: any) => ({
          id: e.id, amount: Number(e.amount), category: e.category, date: e.date
        }));
      } catch (error) {
        console.error("è·å–æ”¯å‡ºåˆ—è¡¨å¤±è´¥:", error);
        return [];
      }
    },
    create: async (data: Expense) => {
      if (isDemoMode) return;
      try {
        await db.insert(expenses).values({
          id: data.id, amount: data.amount, category: data.category, date: data.date
        }).execute();
      } catch (error) {
        console.error("åˆ›å»ºæ”¯å‡ºè®°å½•å¤±è´¥:", error);
      }
    },
    delete: async (id: string) => {
      if (isDemoMode) return;
      try {
        await db.delete(expenses).where(eq(expenses.id, id)).execute();
      } catch (error) {
        console.error("åˆ é™¤æ”¯å‡ºè®°å½•å¤±è´¥:", error);
      }
    }
  },

  users: {
    getAll: async (): Promise<User[]> => {
      if (isDemoMode) return [];
      try {
        const data = await db.select().from(users).orderBy(asc(users.role)).execute();
        return data.map((u: any) => ({
          id: u.id, username: u.username, email: u.email, role: u.role as UserRole,
          name: u.name, partnerId: u.partnerId, modulePermissions: u.modulePermissions
        }));
      } catch (error) {
        console.error("è·å–ç”¨æˆ·åˆ—è¡¨å¤±è´¥:", error);
        return [];
      }
    },
    upsert: async (data: User) => {
      if (isDemoMode) return;
      try {
        // æ ¹ç®¡ç†å‘˜ç¡¬ä¿æŠ¤é€»è¾‘
        if (data.email === 'athendrakomin@proton.me') {
          data.role = UserRole.ADMIN;
        }
        await db.insert(users).values({
          id: data.id, username: data.username, email: data.email, name: data.name,
          role: data.role, partnerId: data.partnerId, modulePermissions: data.modulePermissions,
          updatedAt: new Date()
        }).onConflictDoUpdate({
          target: users.id,
          set: {
            username: data.username,
            email: data.email,
            name: data.name,
            role: data.role,
            partnerId: data.partnerId,
            modulePermissions: data.modulePermissions,
            updatedAt: new Date()
          }
        }).execute();
      } catch (error) {
        console.error("æ›´æ–°ç”¨æˆ·å¤±è´¥:", error);
      }
    },
    delete: async (id: string, requesterEmail?: string) => {
      if (isDemoMode) return;
      try {
        // æ£€æŸ¥æ˜¯å¦ä¸ºæ ¹ç®¡ç†å‘˜
        const targetResult = await db.select({ email: users.email }).from(users).where(eq(users.id, id)).execute();
        const target = targetResult[0];
        if (target?.email === 'athendrakomin@proton.me') throw new Error("ç‰©ç†èµ„äº§é”å®šï¼šæ— æ³•åˆ é™¤æ ¹ç®¡ç†å‘˜ã€‚");
        await db.delete(users).where(eq(users.id, id)).execute();
      } catch (error) {
        console.error("åˆ é™¤ç”¨æˆ·å¤±è´¥:", error);
      }
    }
  },

  payments: {
    getAll: async (): Promise<PaymentMethodConfig[]> => {
      if (isDemoMode) return [];
      try {
        const data = await db.select().from(paymentMethods).orderBy(asc(paymentMethods.sortOrder)).execute();
        return data.map((p: any) => ({
          id: p.id, name: p.name, name_en: p.nameEn, currency: p.currency,
          currency_symbol: p.currencySymbol, exchange_rate: Number(p.exchangeRate),
          isActive: p.isActive, payment_type: p.paymentType, sort_order: p.sortOrder,
          description: p.description, description_en: p.descriptionEn,
          iconType: p.iconType, wallet_address: p.walletAddress, qr_url: p.qrUrl
        }));
      } catch (error) {
        console.error("è·å–æ”¯ä»˜æ–¹å¼åˆ—è¡¨å¤±è´¥:", error);
        return [];
      }
    },
    toggle: async (id: string) => {
      if (isDemoMode) return;
      try {
        const dataResult = await db.select({ isActive: paymentMethods.isActive }).from(paymentMethods).where(eq(paymentMethods.id, id)).execute();
        const record = dataResult[0];
        if (record) {
          await db.update(paymentMethods).set({ 
            isActive: !record.isActive 
          }).where(eq(paymentMethods.id, id)).execute();
        }
      } catch (error) {
        console.error("åˆ‡æ¢æ”¯ä»˜æ–¹å¼çŠ¶æ€å¤±è´¥:", error);
      }
    },
    create: async (data: PaymentMethodConfig) => {
      if (isDemoMode) return;
      try {
        await db.insert(paymentMethods).values({
          id: data.id, name: data.name, nameEn: data.name_en, currency: data.currency,
          currencySymbol: data.currency_symbol, exchangeRate: data.exchange_rate,
          isActive: data.isActive, paymentType: data.payment_type, sortOrder: data.sort_order,
          description: data.description, descriptionEn: data.description_en,
          iconType: data.iconType, walletAddress: data.wallet_address, qrUrl: data.qr_url
        }).execute();
      } catch (error) {
        console.error("åˆ›å»ºæ”¯ä»˜æ–¹å¼å¤±è´¥:", error);
      }
    },
    update: async (data: PaymentMethodConfig) => {
      if (isDemoMode) return;
      try {
        await db.update(paymentMethods).set({
          name: data.name, nameEn: data.name_en, currency: data.currency,
          currencySymbol: data.currency_symbol, exchangeRate: data.exchange_rate,
          isActive: data.isActive, paymentType: data.payment_type, sortOrder: data.sort_order,
          description: data.description, descriptionEn: data.description_en,
          iconType: data.iconType, walletAddress: data.wallet_address, qrUrl: data.qr_url
        }).where(eq(paymentMethods.id, data.id)).execute();
      } catch (error) {
        console.error("æ›´æ–°æ”¯ä»˜æ–¹å¼å¤±è´¥:", error);
      }
    },
    delete: async (id: string) => {
      if (isDemoMode) return;
      try {
        await db.delete(paymentMethods).where(eq(paymentMethods.id, id)).execute();
      } catch (error) {
        console.error("åˆ é™¤æ”¯ä»˜æ–¹å¼å¤±è´¥:", error);
      }
    }
  },

  ingredients: {
    getAll: async (): Promise<Ingredient[]> => {
      if (isDemoMode) return [];
      try {
        const data = await db.select().from(ingredients).orderBy(asc(ingredients.name)).execute();
        return data.map((i: any) => ({
          id: i.id, name: i.name, unit: i.unit, stock: Number(i.stock),
          minStock: Number(i.minStock), category: i.category, last_restocked: i.lastRestocked
        }));
      } catch (error) {
        console.error("è·å–é£Ÿæåˆ—è¡¨å¤±è´¥:", error);
        return [];
      }
    },
    create: async (data: Ingredient) => {
      if (isDemoMode) return;
      try {
        await db.insert(ingredients).values({
          id: data.id, name: data.name, unit: data.unit, stock: data.stock,
          minStock: data.minStock, category: data.category, lastRestocked: data.last_restocked
        }).execute();
      } catch (error) {
        console.error("åˆ›å»ºé£Ÿæè®°å½•å¤±è´¥:", error);
      }
    },
    update: async (data: Ingredient) => {
      if (isDemoMode) return;
      try {
        await db.update(ingredients).set({
          name: data.name, unit: data.unit, stock: data.stock, minStock: data.minStock,
          category: data.category, lastRestocked: data.last_restocked
        }).where(eq(ingredients.id, data.id)).execute();
      } catch (error) {
        console.error("æ›´æ–°é£Ÿæè®°å½•å¤±è´¥:", error);
      }
    },
    delete: async (id: string) => {
      if (isDemoMode) return;
      try {
        await db.delete(ingredients).where(eq(ingredients.id, id)).execute();
      } catch (error) {
        console.error("åˆ é™¤é£Ÿæè®°å½•å¤±è´¥:", error);
      }
    }
  },

  db: {
    getRows: async (table: string) => {
      if (isDemoMode) return [];
      try {
        // æ ¹æ®ä¸åŒçš„è¡¨åä½¿ç”¨å¯¹åº”çš„drizzleè¡¨å¯¹è±¡
        switch(table) {
          case 'orders':
            return await db.select().from(orders).limit(100).execute();
          case 'menu_dishes':
            return await db.select().from(menuDishes).limit(100).execute();
          case 'menu_categories':
            return await db.select().from(menuCategories).limit(100).execute();
          case 'rooms':
            return await db.select().from(rooms).limit(100).execute();
          case 'users':
            return await db.select().from(users).limit(100).execute();
          case 'ingredients':
            return await db.select().from(ingredients).limit(100).execute();
          case 'partners':
            return await db.select().from(partners).limit(100).execute();
          case 'expenses':
            return await db.select().from(expenses).limit(100).execute();
          case 'payment_methods':
            return await db.select().from(paymentMethods).limit(100).execute();
          case 'system_config':
            return await db.select().from(systemConfig).limit(100).execute();
          default:
            return [];
        }
      } catch (error) {
        console.error(`è·å–è¡¨ ${table} æ•°æ®å¤±è´¥:`, error);
        return [];
      }
    }
  },

  archive: {
    exportData: async () => {
      const dishes = await api.dishes.getAll({ role: UserRole.ADMIN });
      const categories = await api.categories.getAll();
      const data = { dishes, categories, exportDate: new Date().toISOString() };
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `jx-cloud-backup-${new Date().toISOString().split('T')[0]}.json`;
      a.click();
    },
    importData: async (file: File) => {
      const text = await file.text();
      const data = JSON.parse(text);
      if (data.dishes) {
        for (const d of data.dishes) await api.dishes.create(d, { role: UserRole.ADMIN });
      }
      if (data.categories) await api.categories.saveAll(data.categories);
    }
  }
};